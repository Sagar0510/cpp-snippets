{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
	// same ids are connected.
	// Example:
	"c++ boilerplate": {
		"prefix": "include",
		"body": [
			"// SAGAR SINGH",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define int long long",
			"#define ll long long",
			"#define ld long double",
			"",
			"const int mod = 1e9 + 7;",
			"const int N = 3e5 + 1;",
			"const int INF = 1e18;",
			"",
			"void solve()",
			"{",
			"    $0",
			"}",
			"",
			"int32_t main()",
			"{",
			"    ios_base::sync_with_stdio;",
			"    cin.tie(NULL);",
			"    cout.tie(0);",
			"    int t = 1;",
			"    cin >> t;",
			"    while (t--)",
			"        solve();",
			"",
			"    return 0;",
			"}",
			""
		],
		"description": "c++ boilerplate"
	},
	"trace": {
		"prefix": "trace",
		"body": [
			"",
			"#define TRACE",
			"#ifdef TRACE",
			"#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)",
			"template <typename Arg1>",
			"void __f(const char *name, Arg1 &&arg1)",
			"{",
			"    cout << name << \" : \" << arg1 << endl;",
			"    // use cerr if u want to display at the bottom",
			"}",
			"template <typename Arg1, typename... Args>",
			"void __f(const char *names, Arg1 &&arg1, Args &&...args)",
			"{",
			"    const char *comma = strchr(names + 1, ',');",
			"    cout.write(names, comma - names) << \" : \" << arg1 << \" | \";",
			"    __f(comma + 1, args...);",
			"}",
			"#else",
			"#define trace(...)",
			"#endif",
			""
		],
		"description": "trace"
	},
	"set bits in a number": {
		"prefix": "setbits",
		"body": [
			"",
			"#define setbits(a) (__builtin_popcountll(a))",
			""
		],
		"description": "set bits in a number"
	},
	"pragma optimizations": {
		"prefix": "pragmaOptimization",
		"body": [
			"",
			"#pragma GCC optimize(\"Ofast\")",
			"#pragma GCC target(\"avx,avx2,fma\")",
			"#pragma GCC optimization(\"unroll-loops\")",
			""
		],
		"description": "pragma optimizations"
	},
	"2D prefix sum": {
		"prefix": "2DPrefixSum",
		"body": [
			"",
			"vector<vector<int>> prefixSum2D(int n,int m,vector<vector<int>>& a) {",
			"    vector<vector<int>> psa(n,vector<int> (m));",
			"    psa[0][0] = a[0][0];",
			"  ",
			"    for (int i = 1; i < m; i++)",
			"        psa[0][i] = psa[0][i - 1] + a[0][i];",
			"    for (int i = 1; i < n; i++)",
			"        psa[i][0] = psa[i - 1][0] + a[i][0];",
			" ",
			"    for (int i = 1; i < n; i++)",
			"        for (int j = 1; j < m; j++)",
			"            psa[i][j] = psa[i - 1][j] + psa[i][j - 1] - psa[i - 1][j - 1] + a[i][j];",
			" ",
			"    return psa;",
			"}",
			""
		],
		"description": "2D prefix sum"
	},
	"all factors of a number": {
		"prefix": "allFactors",
		"body": [
			"",
			"vector<int> factors(int x) {",
			"    vector<int> result;",
			"    int i = 1;",
			"    while(i*i <= x) {",
			"        if(x % i == 0) {",
			"            result.push_back(i);",
			"            if(x/i != i) {",
			"                result.push_back(x/i);",
			"            }",
			"        }",
			"        i++;",
			"    }",
			"    return result;",
			"}",
			""
		],
		"description": "all factors of a number"
	},
	"breadth first search": {
		"prefix": "bfs",
		"body": [
			"",
			"vector<int> adj[N], dist(N,-1);",
			"",
			"void bfs(int s) {",
			"    queue<int> q;",
			"    dist[s] = 0; q.push(s);",
			"    while (q.size()) {",
			"        int u = q.front(); q.pop();",
			"        for (int v : adj[u]) {",
			"            if (dist[v] == -1) {",
			"                dist[v] = dist[u] + 1;",
			"                q.push(v);",
			"            }",
			"        }",
			"    }",
			"}",
			""
		],
		"description": "breadth first search"
	},
	"0/1 breadth first search": {
		"prefix": "bfs_0/1",
		"body": [
			"",
			"vector<pair<int,int>> adj[N];",
			"vector<int> dist;",
			"",
			"void bfs(int s,int n) {",
			"    dist.assign(n + 1, -1);",
			"    deque<int> q;",
			"    dist[s] = 0; q.push_front(s);",
			"    while (q.size()) {",
			"        int u = q.front(); q.pop_front();",
			"        for (auto [v, w] : adj[u]) {",
			"            if (dist[v] == -1) {",
			"                dist[v] = dist[u] + w;",
			"                if (w == 1) q.push_back(v);",
			"                else q.push_front(v);",
			"            }",
			"        }",
			"    }",
			"}",
			"",
			""
		],
		"description": "0-1 BFS"
	},
	"Binary Lifting ": {
		"prefix": "binaryLifting",
		"body": [
			"",
			"struct BinaryLifting {",
			"    int n;",
			"    int maxLog;",
			"    int maxRequirement;",
			"    vector<vector<int>> parent;",
			"    BinaryLifting(int n1, vector<int> *edges, int requirement, int root) {",
			"        n = n1;",
			"        parent.resize(n1+1);  //1 based nodes",
			"        maxLog = log2(requirement + 1);",
			"        maxRequirement = requirement;",
			"        for (int i = 0; i <= n ; i++) {",
			"            parent[i].resize(maxLog + 1);",
			"            for (int j = 0; j <= maxLog; j++) {",
			"                parent[i][j] = -1;",
			"            }",
			"        }",
			"        fillParentTable(root, edges);",
			"    }",
			"    void fillParentTable(int root, vector<int> *edges) {",
			"        vector<bool> visited(n+1);",
			"        dfsBinaryLifting(root, edges, visited);",
			"        int intermediate = -1;",
			"        for (int i = 1; i <= maxLog; i++) {",
			"            for (int j = 0; j <= n; j++) {",
			"                intermediate = parent[j][i - 1];",
			"                if (intermediate != -1) {",
			"                    parent[j][i] = parent[intermediate][i - 1];",
			"                }",
			"            }",
			"        }",
			"    }",
			"    void dfsBinaryLifting(int root, vector<int> *edges, vector<bool> &visited) {",
			"        visited[root] = true;",
			"        for (auto i : edges[root]) {",
			"            if (!visited[i]) {",
			"                parent[i][0] = root;",
			"                dfsBinaryLifting(i, edges, visited);",
			"            }",
			"        }",
			"    }",
			"    int kthParent(int x, int k) {",
			"        for(int i = 0; i <= maxLog; i++){",
			"            if((k >> i) & 1){ ",
			"                if(x == -1)",
			"                    return x;",
			"                x = parent[x][i];",
			"            }",
			"        }",
			"        return x;",
			"    }",
			"};",
			""
		],
		"description": "Binary Lifting "
	},
	"convert binary string to integer": {
		"prefix": "binaryToDecimal",
		"body": [
			"",
			"int binaryToDecimal(string n) {",
			"    string num = n;",
			"    int dec_value = 0;",
			"    int base = 1;",
			"    int len = num.length();",
			"    for (int i = len - 1; i >= 0; i--) {",
			"        if (num[i] == '1')",
			"            dec_value += base;",
			"        base = base * 2;",
			"    }",
			"    return dec_value;",
			"}",
			""
		],
		"description": "convert binary string to integer"
	},
	"bipartite test of a graph": {
		"prefix": "bipartiteTest",
		"body": [
			"",
			"vector<int> adj[N];",
			"bool visited[N];",
			"int col[N];",
			"",
			"bool dfs(int u,int c) {",
			"    visited[u] = 1;",
			"    col[u] = c;",
			"    for (int v : adj[u]) {",
			"        if (!visited[v])",
			"           {if(!dfs(v,c^1)) return false;}",
			"        else if(col[v]==col[u]) return false;  ",
			"    }",
			"    return true;",
			"}",
			""
		],
		"description": "bipartite test of a graph"
	},
	"bridges and articulation points of a graph": {
		"prefix": "bridgeArticulationPt",
		"body": [
			"",
			"vector<int> adj[N];",
			"bool visited[N];",
			"int inn[N],low[N],timer;",
			"",
			"void dfs(int u, int p) {",
			"    visited[u] = 1;",
			"    inn[u]=low[u]=timer++; ",
			"    int child=0;",
			"    for (int v : adj[u]) {",
			"        if (v==p) continue;",
			"        if (visited[v]) low[u]=min(low[u],inn[v]);",
			"        else{",
			"            dfs(v,u);",
			"            low[u]=min(low[u],low[v]);",
			"            child++;",
			"            if(low[v]>inn[u])",
			"            // u -- v is a bridge;",
			"            if(low[v]>=inn[u] and p!=-1)",
			"            // u is an articulation point",
			"        }",
			"    }",
			"    if(p==-1 and child>1)",
			"    // u is an articulation point  ",
			"}",
			"",
			""
		],
		"description": "bridges and articulation points of a graph"
	},
	"check if a number is prime": {
		"prefix": "checkPrime",
		"body": [
			"",
			"bool prime(int a) {",
			"    if (a <= 1) return 0;",
			"    if (a == 2 || a == 3) return 1;",
			"    if (a % 2 == 0 || a % 3 == 0) return 0;",
			"    for (int i = 5; i <= sqrt(a); i += 6)",
			"        if (a % i == 0 || a % (i + 2) == 0)return 0;",
			"    return 1;",
			"}",
			""
		],
		"description": "check if a number is prime"
	},
	"custom hashing function for unordered map": {
		"prefix": "customHash",
		"body": [
			"",
			"struct custom_hash {",
			"    static uint64_t splitmix64(uint64_t x) {",
			"        x += 0x9e3779b97f4a7c15;",
			"        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"        return x ^ (x >> 31);",
			"    }",
			" ",
			"    size_t operator()(uint64_t x) const {",
			"        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
			"        return splitmix64(x + FIXED_RANDOM);",
			"    }",
			"};",
			""
		],
		"description": "custom hashing function for unordered map"
	},
	"cycle detection in a graph": {
		"prefix": "cycleDetection",
		"body": [
			"",
			"vector<int> adj[N];",
			"bool visited[N];",
			"",
			"bool dfs(int u,int p) {",
			"    visited[u] = 1;",
			"    for (int v : adj[u]) {",
			"        if (!visited[v])",
			"           {if(dfs(v,u)) return true;}",
			"        else if(v!=p) return true;  ",
			"    }",
			"    return false;",
			"}"
		],
		"description": "cycle detection in a graph"
	},
	"convert integer to binary string": {
		"prefix": "decimalToBinary",
		"body": [
			"",
			"string decToBinary(int n){",
			"    string binaryNum;",
			"    int i = 0;",
			"    while (n > 0) {",
			"        binaryNum.pb(n % 2 + '0');",
			"        n = n / 2;",
			"        i++;",
			"    }",
			"    reverse(all(binaryNum));",
			"    return binaryNum; ",
			"}",
			""
		],
		"description": "convert integer to binary string"
	},
	"depth first search": {
		"prefix": "dfs",
		"body": [
			"",
			"vector<int> adj[N];",
			"bool visited[N];",
			"",
			"void dfs(int u) {",
			"    visited[u] = 1;",
			"    for (int v : adj[u]) {",
			"        if (!visited[v])",
			"            dfs(v);",
			"    }",
			"}",
			""
		],
		"description": "depth first search"
	},
	"Dijkstra's Algorithm": {
		"prefix": "dijkstra",
		"body": [
			"",
			"vector<pair<int,int> > adj[N];",
			"vector<int> dist(N,INF);",
			"",
			"",
			"void dijkstra(int s) {",
			"    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;",
			"    dist[s] = 0; pq.push({0, s});",
			"    while (pq.size()) {",
			"        auto [d, u] = pq.top(); pq.pop();",
			"        if (d > dist[u]) continue;",
			"        for (auto [v, w] : adj[u]) {",
			"            if (dist[v] > dist[u] + w) {",
			"                dist[v] = dist[u] + w;",
			"                pq.push({dist[v], v});",
			"            }",
			"        }",
			"    } ",
			"}",
			""
		],
		"description": "Dijkstra's Algorithm"
	},
	"Disjoint Sets Union": {
		"prefix": "DSU",
		"body": [
			"",
			"struct DSU {",
			"    int n;",
			"    vector<int> rank;",
			"    vector<int> parent;",
			"    DSU(int n) {",
			"        rank.resize(n+1);//1-based",
			"        parent.resize(n+1);",
			"        for (int i = 1; i <= n; i++) {",
			"            parent[i] = i;",
			"        }",
			"    }",
			"    int get(int a) {",
			"        return parent[a] = (parent[a] == a ? a : get(parent[a]));",
			"    }",
			"    void merge(int a, int b) {",
			"        a = get(a);",
			"        b = get(b);",
			"        if (a == b)",
			"            return;",
			"",
			"        if (rank[a] == rank[b])",
			"            rank[a]++;",
			"",
			"        if (rank[a] < rank[b]) ",
			"            swap(a,b);",
			"",
			"        parent[b]=a;",
			"    }",
			"};",
			""
		],
		"description": "Disjoint Sets Union"
	},
	"Extended Euclidean Algorithm": {
		"prefix": "extEuclid",
		"body": [
			"int exteuclid(int a, int b, int& x, int& y) {",
			"    if (b == 0) {",
			"        x = 1;",
			"        y = 0;",
			"        return a;",
			"    }",
			"    int x1, y1;",
			"    int d = exteuclid(b, a % b, x1, y1);",
			"    x = y1;",
			"    y = x1 - y1 * (a / b);",
			"    return d;",
			"}"
		],
		"description": "Extended Euclidean Algorithm"
	},
	"Fast Exponentiation": {
		"prefix": "fastExponentiation",
		"body": [
			"",
			"int qexp(int a, int b, int m) {",
			"    int res = 1;",
			"    while (b) {",
			"        if (b & 1) res = res * a % m;",
			"        a = a * a % m;",
			"        b >>= 1;",
			"    }",
			"    return res;",
			"}",
			""
		],
		"description": "Fast Exponentiation"
	},
	"Fenwick Tree": {
		"prefix": "fenwickTree",
		"body": [
			"#define LSB(i) ((i) & -(i))",
			"const int maxn = N;",
			"struct fenwick",
			"{",
			"    int A[maxn];",
			"    int query(int i)",
			"    {",
			"        int sum = 0;",
			"        while (i > 0)",
			"            sum += A[i], i -= LSB(i);",
			"        return sum;",
			"    }",
			"    void update(int i, int k)",
			"    {",
			"        if (i < 1)",
			"            return;",
			"        while (i < maxn)",
			"            A[i] += k, i += LSB(i);",
			"    }",
			"    int rquery(int x, int y)",
			"    {",
			"        return query(y) - query(x - 1);",
			"    }",
			"} fenw;"
		],
		"description": "Fenwick Tree"
	},
	"grid breadth first search": {
		"prefix": "gridBFS",
		"body": [
			"",
			"int n,m;",
			"char matrix[N][N]; ",
			"bool visited[N][N];",
			"int dist[N][N];",
			"int dx[]={-1,0,1,0};",
			"int dy[]={0,1,0,-1};",
			" ",
			"bool valid(int x,int y){",
			"  if(x<1||x>n||y<1||y>m) return false;",
			"  if(visited[x][y]) return false;",
			"  return true;",
			"}",
			" ",
			"void bfs(int x,int y) {",
			"    queue<pair<int,int>> q;",
			"    visited[x][y]=1;",
			"    dist[x][y] = 0; q.push({x,y});",
			"    while (q.size()) {",
			"        int xx = q.front().ff;",
			"        int yy = q.front().ss;",
			"        q.pop();",
			"        ",
			"        rep(i,0,4) {",
			"          if(valid(xx+dx[i],yy+dy[i])){",
			"             visited[xx+dx[i]][yy+dy[i]]=1;",
			"             dist[xx+dx[i]][yy+dy[i]]=dist[xx][yy]+1;",
			"             q.push({xx+dx[i],yy+dy[i]});",
			"          }",
			"        }",
			"    }",
			"}",
			""
		],
		"description": "grid breadth first search"
	},
	"grid depth first search": {
		"prefix": "gridDFS",
		"body": [
			"",
			"int n,m;",
			"char ch[N][N]; ",
			"bool visited[N][N];",
			"int dx[]={-1,0,1,0};",
			"int dy[]={0,1,0,-1};",
			"",
			"bool valid(int x,int y){",
			"  if(x<1||x>n||y<1||y>m) return false;",
			"  if(visited[x][y]) return false;",
			"  return true;",
			"}",
			" ",
			"void dfs(int x,int y) {",
			"    visited[x][y] = 1;",
			"    for(int i=0;i<4;i++){",
			"      if(valid(x+dx[i],y+dy[i])){",
			"        dfs(x+dx[i],y+dy[i]);",
			"      }",
			"    }",
			"}",
			"",
			""
		],
		"description": "grid depth first search"
	},
	"Linear Diophantine Equation": {
		"prefix": "linearDiophantineEquation",
		"body": [
			"",
			"int exteuclid(int a, int b, int &x, int &y) {",
			"    if (b == 0) {x = 1, y = 0; return a;}",
			"    int x1, y1, d = exteuclid(b, a % b, x1, y1);",
			"    x = y1;",
			"    y = x1 - y1 * (a / b);",
			"    return d;",
			"}",
			"bool lde(int a, int b, int c, int &x, int &y) {",
			"    int d = exteuclid(abs(a), abs(b), x, y);",
			"    if (c % d) return false; ",
			"    x *= c / d; ",
			"    y *= c / d;",
			"    if (a < 0) x = -x;",
			"    if (b < 0) y = -y;",
			"    return true;",
			"}",
			""
		],
		"description": "Linear Diophantine Equation"
	},
	"Lowest Common Ancestor": {
		"prefix": "lowestCommonAncestor",
		"body": [
			"",
			"struct BinaryLifting {",
			"    int n;",
			"    int maxLog;",
			"    int maxRequirement;",
			"    vector<vector<int>> parent;",
			"    BinaryLifting(int n1, vector<int> *edges, int requirement, int root) {",
			"        n = n1;",
			"        parent.resize(n1+1);  //1 based nodes",
			"        maxLog = log2(requirement + 1);",
			"        maxRequirement = requirement;",
			"        for (int i = 0; i <= n ; i++) {",
			"            parent[i].resize(maxLog + 1);",
			"            for (int j = 0; j <= maxLog; j++) {",
			"                parent[i][j] = -1;",
			"            }",
			"        }",
			"        fillParentTable(root, edges);",
			"    }",
			"    void fillParentTable(int root, vector<int> *edges) {",
			"        vector<bool> visited(n+1);",
			"        dfsBinaryLifting(root, edges, visited);",
			"        int intermediate = -1;",
			"        for (int i = 1; i <= maxLog; i++) {",
			"            for (int j = 0; j <= n; j++) {",
			"                intermediate = parent[j][i - 1];",
			"                if (intermediate != -1) {",
			"                    parent[j][i] = parent[intermediate][i - 1];",
			"                }",
			"            }",
			"        }",
			"    }",
			"    void dfsBinaryLifting(int root, vector<int> *edges, vector<bool> &visited) {",
			"        visited[root] = true;",
			"        for (auto i : edges[root]) {",
			"            if (!visited[i]) {",
			"                parent[i][0] = root;",
			"                dfsBinaryLifting(i, edges, visited);",
			"            }",
			"        }",
			"    }",
			"    int kthParent(int x, int k) {",
			"        for(int i = 0; i <= maxLog; i++){",
			"            if((k >> i) & 1){ ",
			"                if(x == -1)",
			"                    return x;",
			"                x = parent[x][i];",
			"            }",
			"        }",
			"        return x;",
			"    }",
			"};",
			"",
			"struct LCA {",
			"    int n;",
			"    vector<int> level;",
			"    LCA(int n1, vector<int> *edges, int root) {",
			"        n = n1;",
			"        level.resize(n+1);",
			"        dfsLCA(root, edges, -1);",
			"    }",
			"    void dfsLCA(int root, vector<int> *edges, int parent) {",
			"        for (auto i : edges[root]) {",
			"            if (i != parent) {",
			"                level[i] = level[root] + 1;",
			"                dfsLCA(i, edges, root);",
			"            }",
			"        }",
			"    }",
			"    int getLCA(int a, int b, BinaryLifting &bl_object) {",
			"        if (level[a] > level[b]) {",
			"            swap(a, b);",
			"        }",
			"        b = bl_object.kthParent(b, level[b] - level[a]);",
			"        if (a == b)",
			"            return a;",
			"        for (int i = bl_object.maxLog; i >= 0; i--) {",
			"            int parent1 = bl_object.parent[a][i];",
			"            int parent2 = bl_object.parent[b][i];",
			"            if (parent2 != parent1 && parent1 != -1 && parent2 != -1) {",
			"                a = parent1;",
			"                b = parent2;",
			"            }",
			"        }",
			"        return bl_object.parent[a][0];",
			"    }",
			"};",
			""
		],
		"description": "Lowest Common Ancestor"
	},
	"Modulo Inverse": {
		"prefix": "modInverse",
		"body": [
			"int exteuclid(int a, int b, int& x, int& y) {",
			"    if (b == 0) {",
			"        x = 1;",
			"        y = 0;",
			"        return a;",
			"    }",
			"    int x1, y1;",
			"    int d = exteuclid(b, a % b, x1, y1);",
			"    x = y1;",
			"    y = x1 - y1 * (a / b);",
			"    return d;",
			"}",
			"int modinv(int a, int m) {",
			"    int x, y;",
			"    exteuclid(a, m, x, y);",
			"    return (m + x % m) % m;",
			"}",
			""
		],
		"description": "Modulo Inverse"
	},
	"Modulo Multiplication": {
		"prefix": "modMultiplication",
		"body": [
			"",
			"int mod_multiplication(int a,int b){ // (x*y)%mod with intermediate states = no overflow",
			"    int res=0;",
			"    while(b){",
			"        if(b&1) res=(res+a)%mod;",
			"        a=(a+a)%mod;",
			"        b>>=1;",
			"    }",
			"    return res;",
			"}",
			""
		],
		"description": "Modulo Multiplication"
	},
	"Modulo Arithmetic": {
		"prefix": "moduloArithmetic",
		"body": [
			"",
			"int qexp(int a, int b, int mod) {int res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}",
			"int mod_inv(int n,int m){return qexp(n,mod-2,m);} // for prime mod",
			"int add_mod(int a, int b, int m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}",
			"int multiply_mod(int a, int b, int m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}",
			"int subtract_mod(int a, int b, int m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}",
			"int divide_mod(int a, int b, int m) {a = a % m; b = b % m; return (multiply_mod(a, mod_inv(b, m), m) + m) % m;}  //only for prime m",
			""
		],
		"description": "Modulo Arithmetic"
	},
	"choose r out of n choices": {
		"prefix": "ncr",
		"body": [
			"",
			"vector<vector<int>> ncr(1001,vector<int> (1001)); //upto 1000C1000",
			"",
			"void calcncr(){",
			"    ncr[0][0]=1;",
			"    for(int n=0;n<=1000;n++){",
			"        ncr[n][0]=1;",
			"        for(int r=1;r<n;r++) ncr[n][r]=ncr[n-1][r]+ncr[n-1][r-1];",
			"        ncr[n][n]=1;",
			"    }",
			"}",
			"",
			""
		],
		"description": "choose r out of n choices"
	},
	"choose r out of n choices modulo M": {
		"prefix": "ncrMod",
		"body": [
			"",
			"int qexp(int a, int b, int mod) {int res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}",
			"int mod_inv(int n,int m){return qexp(n,mod-2,m);} // for prime mod",
			"int mod_add(int a, int b, int m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}",
			"int mod_mul(int a, int b, int m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}",
			"int mod_sub(int a, int b, int m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}",
			"int mod_div(int a, int b, int m) {a = a % m; b = b % m; return (mod_mul(a, mod_inv(b, m), m) + m) % m;}  //only for prime m",
			"",
			"vector<int> fact;",
			"void computeFact(int n){",
			"    fact.resize(n+1);",
			"    fact[0]=1;",
			"    rep(i,1,n+1) fact[i]=mod_mul(fact[i-1],i,mod);",
			"}",
			"int ncr(int n,int r,int mod){",
			"    if(n<r) return 0;",
			"    if(r==0) return 1;",
			"    return (((fact[n]*mod_inv(fact[r],mod))%mod)*(mod_inv(fact[n-r],mod)))%mod;",
			"}",
			""
		],
		"description": "choose r out of n choices modulo M"
	},
	"pair sort comparator": {
		"prefix": "pairSort",
		"body": [
			"",
			"bool ffDECssINC(const pair<int,int> &a, ",
			"              const pair<int,int> &b) ",
			"{   ",
			"    if(a.first!=b.first) return (a.first>b.first); ",
			"    return (a.second < b.second); ",
			"} ",
			"// > : decreasing sort < : increasing sort",
			""
		],
		"description": "pair sort comparator"
	},
	"Pallindrome Table": {
		"prefix": "pallindromeTable",
		"body": [
			"",
			"vector<vector<int>> pallindromeTable(string s){",
			"    int n=s.length();",
			"    vector<vector<int>> dp(n,vector<int> (n));",
			"",
			"    for(int i=n-1;i>=0;i--)",
			"        for(int j=i;j<n;j++)",
			"            if(s[i]==s[j] and ((j-i)<2 or dp[i+1][j-1]))",
			"                dp[i][j]=1;",
			"    return dp;",
			"}",
			""
		],
		"description": "Pallindrome Table"
	},
	"Policy Based Data Structure": {
		"prefix": "pbds",
		"body": [
			"",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"// less_equal for ordered multiset",
			"#define pbds tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>"
		],
		"description": "Policy Based Data Structure"
	},
	"check if a number is a power of two": {
		"prefix": "powerOfTwo",
		"body": [
			"",
			"bool isPowerOfTwo(int n)",
			"{",
			"   if(n==0)",
			"   return false;",
			"   return (ceil(log2(n)) == floor(log2(n)));",
			"}",
			""
		],
		"description": "check if a number is a power of two"
	},
	"Prim's Algorithm": {
		"prefix": "primsAlgorithm",
		"body": [
			"",
			"vector<pair<int,int> > adj[N];",
			"",
			"int prims(int n){",
			"    priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;",
			"    bool visited[n+1]={0};",
			"    visited[1]=1;",
			"    int ans=0;",
			"",
			"    for(auto x:adj[1]) pq.push({x.ss,{x.ff,1}});",
			"",
			"    while(pq.size()){",
			"        auto x = pq.top(); pq.pop();",
			"        if(visited[x.ss.ff]) continue;",
			"        visited[x.ss.ff]=1;",
			"        // cout<<\"[\"<<x.ss.ff<<\"-\"<<x.ss.ss<<\"@\"<<x.ff<<\"]\\n\";",
			"        ans+=x.ff;",
			"        for(auto y:adj[x.ss.ff])",
			"            pq.push({y.ss,{y.ff,x.ss.ff}});",
			"    }",
			"",
			"    rep(i,1,n+1)",
			"        if(!visited[i])",
			"            return -1;",
			"    return ans;",
			"}",
			""
		],
		"description": "Prim's Algorithm"
	},
	"Prime Factors of an Integer": {
		"prefix": "primeFactors",
		"body": [
			"",
			"vector<int> primeFactors(int n) {",
			"    vector<int> pfs;",
			"    while (n % 2 == 0) {",
			"        pfs.pb(2);",
			"        n = n / 2;",
			"    }",
			"",
			"    for (int i = 3; i <= sqrt(n); i = i + 2) {",
			"        while (n % i == 0) {",
			"            pfs.pb(i);",
			"            n = n / i;",
			"        }",
			"    }",
			"    if (n > 2)",
			"        pfs.pb(n);",
			"    return pfs;",
			"}",
			""
		],
		"description": "Prime Factors of an Integer"
	},
	"Priority Queue Custom Sort Comparator": {
		"prefix": "priorityQueueCustomSortComparator",
		"body": [
			"",
			"struct comp{",
			"    bool operator ()(pair<int,string> &A,pair<int,string> &B){",
			"        if(A.first!=B.first) return A.first>B.first;",
			"        return A.second < B.second;",
			"    }",
			"};",
			""
		],
		"description": "Priority Queue Custom Sort Comparator"
	},
	"Segment Tree": {
		"prefix": "segtree",
		"body": [
			"",
			"struct node",
			"{",
			"    //**1",
			"    int sum = 0;",
			"    // use more variables according to the things you want from each node in segtree",
			"    // these default values should be identity_element",
			"    node(){}",
			"    node(int val){",
			"        //**2",
			"        sum = val;",
			"        // constructor, what each value in LEAF should store",
			"    }",
			"    void merge(const node &l,const node &r){ ",
			"        //**3",
			"        sum = l.sum + r.sum;",
			"        //how would you build up the value of each node from the children",
			"        // if we wanted the maximum, then we would do",
			"        // like sum = max(l.sum,r.sum) where l and r are left and right children",
			"    }",
			"};",
			"",
			"struct update",
			"{",
			"    // **4",
			"    int v = 0; ",
			"    // use more variables if you want more things to update, for eg intead of v, we might want to add a sequence or AP on the range",
			"    // these default values should be identity_transformation",
			"    update(){}",
			"    update(int val){",
			"        //**5",
			"        v = val;",
			"        //initialising update values",
			"    }",
			"    // combine the current update with the other update (see keynotes)",
			"    void combine(update &other,const int32_t &tl,const int32_t &tr){",
			"        //**6",
			"        v += other.v;",
			"        // you can be sure that the \"other\" is newer than current",
			"        // this where you update the upd value of the lazy man",
			"    }",
			"    // store the correct information in the node x",
			"    void apply(node &x,const int32_t &tl,const int32_t &tr){",
			"        //**7",
			"        x.sum += (tr - tl + 1) * v;",
			"        // each value in a node gets correct value of pushdown",
			"    }",
			"};",
			"",
			"template<typename node,typename update>",
			"struct segtree",
			"{",
			"    int len;",
			"    vector<node> t;",
			"    vector<update> u;",
			"    vector<bool> lazy;",
			"    node identity_element;",
			"    update identity_transformation;",
			"    segtree(int l){",
			"        len = l;",
			"        t.resize(4 * len);",
			"        u.resize(4 * len);",
			"        lazy.resize(4 * len);",
			"        identity_element = node();",
			"        identity_transformation = update();",
			"    }",
			" ",
			"    void pushdown(const int32_t &v, const int32_t &tl, const int32_t &tr){",
			"        if(!lazy[v]) return;",
			"        int32_t tm = (tl + tr) >> 1;",
			"        apply(v<<1,tl,tm,u[v]);",
			"        apply(v<<1|1,tm+1,tr,u[v]);",
			"        u[v] = identity_transformation;",
			"        lazy[v] = 0;",
			"    }",
			" ",
			"    void apply(const int32_t &v, const int32_t &tl, const int32_t &tr, update upd){",
			"        if(tl != tr){",
			"            lazy[v] = 1;",
			"            u[v].combine(upd,tl,tr);",
			"        }",
			"        upd.apply(t[v],tl,tr);",
			"    }",
			" ",
			"    template<typename T>",
			"    void build(const T &arr,const int32_t &v, const int32_t &tl, const int32_t &tr){",
			"        if(tl == tr){",
			"            t[v] = arr[tl];",
			"            return;",
			"        }",
			"        int32_t tm = (tl + tr) >> 1;",
			"        build(arr,v<<1,tl,tm);",
			"        build(arr,v<<1|1,tm+1,tr);",
			"        t[v].merge(t[v<<1],t[v<<1|1]);",
			"    }",
			" ",
			"    node query(const int32_t &v,const int32_t &tl,const int32_t &tr,const int32_t &l,const int32_t &r){",
			"        if(l > tr || r < tl){",
			"            return identity_element;",
			"        }",
			"        if(tl >= l && tr <= r){",
			"            return t[v];",
			"        }",
			"        pushdown(v,tl,tr);",
			"        int32_t tm = (tl + tr) >> 1;",
			"        node a = query(v<<1,tl,tm,l,r),b = query(v<<1|1,tm+1,tr,l,r),ans;",
			"        ans.merge(a,b);",
			"        return ans;",
			"    }",
			" ",
			"    void rupd(const int32_t &v,const int32_t &tl,const int32_t &tr,const int32_t &l,const int32_t &r,const update &upd){",
			"        if(l > tr || r < tl){",
			"            return;",
			"        }",
			"        if(tl >= l && tr <= r){",
			"            apply(v,tl,tr,upd);",
			"            return;",
			"        }",
			"        pushdown(v,tl,tr);",
			"        int32_t tm = (tl + tr) >> 1;",
			"        rupd(v<<1,tl,tm,l,r,upd);",
			"        rupd(v<<1|1,tm+1,tr,l,r,upd);",
			"        t[v].merge(t[v<<1],t[v<<1|1]);",
			"    }",
			" ",
			"    public:",
			"    template<typename T>",
			"    void build(const T &arr){",
			"        build(arr,1,0,len-1);",
			"    }",
			"    node query(const int32_t &l,const int32_t &r){",
			"        return query(1,0,len-1,l,r);",
			"    }",
			"    void rupd(const int32_t &l,const int32_t &r,const update &upd){",
			"        rupd(1,0,len-1,l,r,upd);",
			"    }",
			"};",
			""
		],
		"description": "Priority Queue Custom Sort Comparator"
	},
	"Sieve of Eratosthenes": {
		"prefix": "sieve",
		"body": [
			"",
			"vector<int> sieve(int n) {",
			"    vector<int> primes, is_prime(n + 1, 1);",
			"    for (int i = 2; i * i <= n; i++)",
			"        if (is_prime[i])",
			"            for (int j = i + i; j <= n; j += i)",
			"                is_prime[j] = 0;",
			"    for (int i = 2; i <= n; i++)",
			"        if (is_prime[i])",
			"            primes.push_back(i);",
			"    return primes;",
			"}",
			""
		],
		"description": "Sieve of Eratosthenes"
	},
	"String Hashing": {
		"prefix": "stringHashing",
		"body": [
			"",
			"mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
			"/*---------------------------------------------------------------------------------------------------------------------------*/",
			"int gcd(int a, int b) {if (b > a) {return gcd(b, a);} if (b == 0) {return a;} return gcd(b, a % b);}",
			"int expo(int a, int b, int mod) {int res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}",
			"void extendgcd(int a, int b, int*v) {if (b == 0) {v[0] = 1; v[1] = 0; v[2] = a; return ;} extendgcd(b, a % b, v); int x = v[1]; v[1] = v[0] - v[1] * (a / b); v[0] = x; return;} //pass an arry of size1 3",
			"int mminv(int a, int b) {int arr[3]; extendgcd(a, b, arr); return arr[0];} //for non prime b",
			"int mminvprime(int a, int b) {return expo(a, b - 2, b);}",
			"bool revsort(int a, int b) {return a > b;}",
			"int combination(int n, int r, int m, int *fact, int *ifact) {int val1 = fact[n]; int val2 = ifact[n - r]; int val3 = ifact[r]; return (((val1 * val2) % m) * val3) % m;}",
			"void google(int t) {cout << \"Case #\" << t << \": \";}",
			"vector<int> sieve(int n) {int*arr = new int[n + 1](); vector<int> vect; for (int i = 2; i <= n; i++)if (arr[i] == 0) {vect.push_back(i); for (int j = 2 * i; j <= n; j += i)arr[j] = 1;} return vect;}",
			"int mod_add(int a, int b, int m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}",
			"int mod_mul(int a, int b, int m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}",
			"int mod_sub(int a, int b, int m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}",
			"int mod_div(int a, int b, int m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;}  //only for prime m",
			"int phin(int n) {int number = n; if (n % 2 == 0) {number /= 2; while (n % 2 == 0) n /= 2;} for (int i = 3; i <= sqrt(n); i += 2) {if (n % i == 0) {while (n % i == 0)n /= i; number = (number / i * (i - 1));}} if (n > 1)number = (number / n * (n - 1)) ; return number;} //O(sqrt(N))",
			"int getRandomNumber(int l, int r) {return uniform_int_distribution<int>(l, r)(rng);} ",
			"/*--------------------------------------------------------------------------------------------------------------------------*/",
			"",
			"struct Hashing{",
			"    string s;",
			"    int n;",
			"    int primes;",
			"    vector<int> hashPrimes = {1000000009, 100000007};",
			"    const int base = 31;",
			"    vector<vector<int>> hashValues;",
			"    vector<vector<int>> powersOfBase;",
			"    Hashing(string a){",
			"        primes = (hashPrimes).size();",
			"        hashValues.resize(primes);",
			"        powersOfBase.resize(primes);",
			"        s = a;",
			"        n = s.length(); ",
			"        for(int i = 0; i < (hashPrimes).size(); i++) {",
			"            powersOfBase[i].resize(n + 1);",
			"            powersOfBase[i][0] = 1;",
			"            for(int j = 1; j <= n; j++){",
			"                powersOfBase[i][j] = (base * powersOfBase[i][j - 1]) % hashPrimes[i];",
			"            }",
			"        }",
			"        for(int i = 0; i < (hashPrimes).size(); i++) {",
			"            hashValues[i].resize(n);",
			"            for(int j = 0; j < n; j++){",
			"                hashValues[i][j] = ((s[j] - 'a' + 1LL) * powersOfBase[i][j]) % hashPrimes[i];",
			"                hashValues[i][j] = (hashValues[i][j] + (j > 0 ? hashValues[i][j - 1] : 0LL)) % hashPrimes[i];",
			"            }",
			"        }",
			"    }",
			"    void addCharacter(char ch){",
			"        s += ch;",
			"        n = (s).size();",
			"        for(int i = 0; i < (hashPrimes).size(); i++){",
			"            while((powersOfBase[i]).size() < (s).size()){",
			"                powersOfBase[i].push_back((powersOfBase[i].back() * base) % hashPrimes[i]);   ",
			"            }",
			"        }",
			"        for(int i = 0; i < (hashPrimes).size(); i++){",
			"            while((hashValues[i]).size() < (s).size()){",
			"                if((hashValues[i]).size() == 0){",
			"                    hashValues[i].push_back((s[0] - 'a' + 1LL) % hashPrimes[i]);",
			"                }else{",
			"                    int extraHash = hashValues[i].back() + ((s.back() - 'a' + 1LL) * powersOfBase[i][(s).size() - 1]) % hashPrimes[i];",
			"                    hashValues[i].push_back((extraHash + hashPrimes[i]) % hashPrimes[i]);",
			"                }",
			"            }",
			"        }",
			"    }",
			"    vector<int> substringHash(int l, int r){ // extra O(log) factor",
			"        vector<int> hash(primes);",
			"        for(int i = 0; i < primes; i++){",
			"            int val1 = hashValues[i][r];",
			"            int val2 = l > 0 ? hashValues[i][l - 1] : 0LL;",
			"            hash[i] = mod_mul(mod_sub(val1, val2, hashPrimes[i]), mminvprime(powersOfBase[i][l], hashPrimes[i]), hashPrimes[i]);",
			"        }",
			"        return hash;",
			"    }",
			"    bool compareSubstrings(int l1, int r1, int l2, int r2){ // use this for comparing strings faster",
			"        if(l1 > l2){",
			"            swap(l1, l2);",
			"            swap(r1, r2);",
			"        }",
			"        for(int i = 0; i < primes; i++){",
			"            int val1 = mod_sub(hashValues[i][r1], (l1 > 0 ? hashValues[i][l1 - 1] : 0LL), hashPrimes[i]);",
			"            int val2 = mod_sub(hashValues[i][r2], (l2 > 0 ? hashValues[i][l2 - 1] : 0LL), hashPrimes[i]);",
			"            if(mod_mul(val1, powersOfBase[i][l2 - l1], hashPrimes[i]) != val2)",
			"                return false;",
			"        }   ",
			"        return true;",
			"    }",
			"};",
			""
		],
		"description": "Sieve of Eratosthenes"
	},
	"Convert String to Long Long": {
		"prefix": "stringToInt",
		"body": [
			"",
			"int qexp(int a, int b) {",
			"    int res = 1;",
			"    while (b) {",
			"        if (b & 1) res = res * a  % mod;",
			"        a = a * a  % mod;",
			"        b >>= 1;",
			"    }",
			"    return res;",
			"}",
			"",
			"int stringToInt(str s){",
			"    int res=0,n=s.size();",
			"    repr(i,n-1,0) res+=(s[i]-'0')*qexp(10,n-i-1);",
			"    return res;",
			"}",
			""
		],
		"description": "Convert String to Long Long"
	},
	"Kosaraju's Algorithm Strongly Connected Components": {
		"prefix": "stronglyConnectedComponents",
		"body": [
			"",
			"struct StronglyConnectedComponents",
			"{",
			"    int n;",
			"    vector<int> vis;",
			"    vector<int> visTranspose;",
			"    vector<int> topSort;",
			"    vector<vector<int>> adj;",
			"    vector<vector<int>> transposeAdj;",
			"    vector<vector<int>> SCC;",
			"",
			"    StronglyConnectedComponents(vector<vector<int>> &adjj,int n){",
			"        this->n = n;",
			"        adj.resize(n+1);",
			"        vis.resize(n+1);",
			"        transposeAdj.resize(n+1);",
			"        visTranspose.resize(n+1);",
			"",
			"        for(int i=1;i<=n;i++)",
			"            for(auto j:adjj[i])",
			"                adj[i].push_back(j),",
			"                transposeAdj[j].push_back(i);",
			"",
			"        for(int i=1;i<=n;i++)",
			"            if(!vis[i])",
			"                dfsFindTopsort(i);",
			"",
			"        reverse(topSort.begin(),topSort.end());",
			"        kosaraju();",
			"    }",
			"    void dfsFindTopsort(int u){",
			"        vis[u]=1;",
			"        for(auto v:adj[u])",
			"            if(!vis[v])",
			"                dfsFindTopsort(v);",
			"        topSort.push_back(u);",
			"    }",
			"    void dfsFindSCC(int u,vector<int> &cur){",
			"        visTranspose[u]=1;",
			"        cur.push_back(u);",
			"        for(auto v:transposeAdj[u])",
			"            if(!visTranspose[v])",
			"                dfsFindSCC(v,cur);",
			"    }",
			"    void kosaraju(){",
			"        for(int i=0;i<topSort.size();i++)",
			"            if(!visTranspose[topSort[i]]){",
			"                vector<int> cur;",
			"                dfsFindSCC(topSort[i],cur);",
			"                SCC.push_back(cur);",
			"            }",
			"    }",
			"};",
			""
		],
		"description": "Kosaraju's Algorithm Strongly Connected Components"
	},
	"Take Unknown Sized Input": {
		"prefix": "takeUnknownSizedInput",
		"body": [
			"",
			"vector<int> takeUnkownInput(){",
			"    vector<int> v;",
			"    string s;",
			"    ll data;",
			"    getline(cin, s);",
			"    istringstream iss(s);",
			"    while (iss >> data)",
			"          v.push_back(data);",
			"",
			"    return v;",
			"}",
			""
		],
		"description": "Take Unknown Sized Input"
	},
	"Kahn's Algorithm for Topological Sorting": {
		"prefix": "topsort",
		"body": [
			"",
			"vector<int> adj[N];",
			"bool visited[N];",
			"int IN[N];",
			"vector<int> topsort;",
			"",
			"bool kahn(int &n)",
			"{",
			"    queue<int> q;",
			"    rep(i, 1, n + 1)",
			"    {",
			"        if (IN[i] == 0)",
			"            q.push(i), topsort.pb(i);",
			"    }",
			"    while (!q.empty())",
			"    {",
			"        int x = q.front();",
			"        q.pop();",
			"        for (auto y : adj[x])",
			"        {",
			"            IN[y]--;",
			"            if (IN[y] == 0)",
			"                q.push(y), topsort.pb(y);",
			"        }",
			"    }",
			"    return (topsort.size() == n);",
			"}"
		],
		"description": "Kahn's Algorithm for Topological Sorting"
	},
	"Take unknown sized string input": {
		"prefix": "takeUnknownSizedStringInput",
		"body": [
			"",
			"vector<string> takeUnkownInput(){",
			"    vector<string> v;",
			"    string s;",
			"    string data;",
			"    getline(cin, s);",
			"    istringstream iss(s);",
			"    while (iss >> data)",
			"          v.push_back(data);",
			"",
			"    return v;",
			"}",
			""
		],
		"description": "Take unknown sized string input"
	}
}